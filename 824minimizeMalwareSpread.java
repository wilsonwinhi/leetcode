public class UnionFind {
    int[] boss;
    int[] sz;
    // int cnt;
    public UnionFind(int n) {
        boss = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            boss[i] = i;
            sz[i] = 1;
        }
    }
    int find(int x) {
        if (x != boss[x])
            boss[x] = find(boss[x]);
        return boss[x];
    }
    void union(int a, int b) {
        sz[find(b)] += sz[find(a)];
        boss[find(a)] = boss[b];
    }
    int size(int i) {
        return sz[find(i)];
    }
}


class Solution {
    /*
    ** build a union find class that also supports size of the union
    */
    public int minMalwareSpread(int[][] graph, int[] initial) {
        // union find
        int n = graph.length;
        UnionFind uf = new UnionFind(n);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (graph[i][j] == 1)
                    uf.union(i, j);
            }
        }
        int[] mal = new int[n];
        for (int i = 0; i < initial.length; i++) {
            mal[uf.find(i)]++;
        }
        int res = 0;
        int index = n;
        for (int i = 0; i < initial.length; i++) {
            int bad = initial[i];
            if (uf.size(bad) > res) {
                res = uf.size(bad);
                index = bad;
            }
            if (uf.size(bad) == res && index > bad) {
                index = bad;
            }
        }
        return index;         
    }
}
